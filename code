1.两数之和
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        c={}
        for i,n in enumerate(nums):
            if n in c:
                return [i,c[n]]
            c[target-n]=i
2.字母异位词分组
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        d=defaultdict(list)
        for s in strs:
            sorted_s=''.join(sorted(s))
            d[sorted_s].append(s)
        return list(d.values())
3.最长连续序列
class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        st = set(nums)  
        ans = 0
        for x in st:
            if x - 1 in st:
                continue
            y = x + 1
            while y in st:
                y += 1
            ans = max(ans, y - x) 
        return ans
4.移动零
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        i0 = 0
        for i in range(len(nums)):
            if nums[i]:
                nums[i], nums[i0] = nums[i0], nums[i]
                i0 += 1
5.盛最多水的容器
class Solution:
    def maxArea(self, height: List[int]) -> int:
        ans = left = 0
        right = len(height) - 1
        while left < right:
            area = (right - left) * min(height[left], height[right])
            ans = max(ans, area)
            if height[left] < height[right]:
                left += 1
            else:
                right -= 1
        return ans
6.三数之和
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        nums.sort()
        ans = []
        n = len(nums)
        for i in range(n - 2):
            x = nums[i]
            if i > 0 and x == nums[i - 1]:  # 跳过重复数字
                continue
            if x + nums[i + 1] + nums[i + 2] > 0:  # 优化一
                break
            if x + nums[-2] + nums[-1] < 0:  # 优化二
                continue
            j = i + 1
            k = n - 1
            while j < k:
                s = x + nums[j] + nums[k]
                if s > 0:
                    k -= 1
                elif s < 0:
                    j += 1
                else:  # 三数之和为 0
                    # j = i+1 表示刚开始双指针，此时 j 左边没有数字
                    # nums[j] != nums[j-1] 说明与上一轮循环的三元组不同
                    if j == i + 1 or nums[j] != nums[j - 1]:
                        ans.append([x, nums[j], nums[k]])
                    j += 1
                    k -= 1
        return ans
